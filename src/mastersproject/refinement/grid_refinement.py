import logging
from pathlib import Path
from typing import Generator, Union

import numpy as np
import scipy.sparse as sps

import porepy as pp
from porepy.fracs.meshing import grid_list_to_grid_bucket
from porepy.fracs.simplex import tetrahedral_grid_from_gmsh
from util.logging_util import trace

logger = logging.getLogger(__name__)


@trace(logger)
def refine_mesh_by_splitting(
    in_file: Union[str, Path],
    out_file: Union[str, Path],
    dim: int,
    gb_set_projections: bool = True,
) -> Generator[pp.GridBucket, None, None]:
    """ Refine a mesh by splitting using gmsh

    The method generates refinements on the fly
    by yielding GridBuckets as desired.

    Note:
    When the desired number of refinements is reached,
    you should call
        refine_mesh_by_splitting.close()
    so that gmsh.finalize() is called.

    Parameters
    ----------
    in_file : Union[str, Path]
        path to .geo file to read
    out_file : Union[str, Path]
        path to new .msh file to store mesh in,
        excluding the ending '.msh'.
    dim : int {2, 3}
        Dimension of domain to mesh
    gb_set_projections : bool (Default: True)
        Call pp.contact_conditions.set_projections(gb)
        before yielding result
    Returns
    -------
    Generator[gb]
        A generator for the refined grid buckets, starting with the coarsest.
    """
    # Ensure that in- and out paths are formatted correctly.
    assert Path(in_file).is_file()
    out_file = Path(out_file)
    out_file = out_file.parent / out_file.stem

    try:
        import gmsh
    except ModuleNotFoundError:
        raise ModuleNotFoundError(
            "To run gmsh python api on your system, "
            "download the relevant gmsh*-sdk.* from http://gmsh.info/bin/. "
            "Then, Add the 'lib' directory from the SDK to PYTHONPATH: \n"
            "export PYTHONPATH=${PYTHONPATH}:path/to/gmsh*-sdk.*/lib"
        )

    # gmsh must always be finalized after it has be initialized
    # (see 'finally' clause).
    # Therefore, we wrap the entire function body in a try-finally context.
    try:
        # Initialize gmsh and generate the first (coarsest) mesh
        gmsh.initialize()
        gmsh.open(in_file)
        gmsh.model.mesh.generate(dim=dim)

        num_refinements = 0

        # Enter an infinite loop
        while True:
            out_file_name = f"{out_file}_{num_refinements}.msh"

            # The first mesh is already done.
            # Start refining all subsequent meshes.
            if num_refinements > 0:
                gmsh.model.mesh.refine()  # Refine the mesh

            gmsh.write(out_file_name)  # Write the result to '.msh' file
            # Generate List[pp.Grid]
            grids = tetrahedral_grid_from_gmsh(file_name=out_file_name)
            # Convert List[pp.Grid] to pp.GridBucket
            gb = grid_list_to_grid_bucket(grids)

            # Set projection operators for mixed-dimensional grids
            if gb_set_projections:
                pp.contact_conditions.set_projections(gb)

            # yield the resulting grid bucket
            yield gb

            # finally, prepare the next iteration
            num_refinements += 1
    finally:
        # When refine_mesh_by_splitting.close() is called, we get here.
        gmsh.finalize()


@trace(logger)
def gb_coarse_fine_cell_mapping(
    gb: pp.GridBucket, gb_ref: pp.GridBucket, tol=1e-8
) -> None:
    """ Wrapper for coarse_fine_cell_mapping to construct mapping for grids in
    GridBucket.

    Adds a node_prop to each grid in gb. The key is 'coarse_fine_cell_mapping',
    and is the mapping generated by 'coarse_fine_cell_mapping(...)'.

    Note: No node prop is added to the reference grids in gb_ref.

    Parameters
    ----------
    gb : pp.GridBucket
        Coarse grid bucket
    gb_ref : pp.GridBucket
        Refined grid bucket
    tol : float, Optional
        Tolerance for point_in_poly* -methods
    """

    grids = gb.get_grids()
    grids_ref = gb_ref.get_grids()

    assert len(grids) == len(
        grids_ref
    ), "Weakly check that GridBuckets refer to same domains"
    assert np.allclose(
        np.append(*gb.bounding_box()), np.append(*gb_ref.bounding_box())
    ), "Weakly check that GridBuckets refer to same domains"

    # This method assumes a consistent node ordering between grids.
    # At least assign one.
    gb.assign_node_ordering(overwrite_existing=False)
    gb_ref.assign_node_ordering(overwrite_existing=False)

    # Add node prop on the coarse grid to map from coarse to fine cells.
    gb.add_node_props(keys="coarse_fine_cell_mapping")

    for i in np.arange(len(grids)):
        g, g_ref = grids[i], grids_ref[i]

        node_num = gb.node_props(g, "node_number")
        node_num_ref = gb_ref.node_props(g_ref, "node_number")
        assert node_num == node_num_ref, "Weakly check that grids refer to same domain."

        # Compute the mapping for this grid-pair,
        # and assign the result to the node of the coarse gb
        mapping = coarse_fine_cell_mapping(g, g_ref, point_in_poly_tol=tol)
        gb.set_node_prop(g, key="coarse_fine_cell_mapping", val=mapping)


@trace(logger)
def coarse_fine_cell_mapping(
    g: pp.Grid, g_ref: pp.Grid, point_in_poly_tol=1e-8
) -> sps.csc_matrix:
    """ Construct a mapping between cells of a grid and its refined version

    Assuming a regular and a refined mesh, where the refinement is executed by
    splitting.
    I.e. a cell in the refined grid is completely contained within a cell
    in the coarse grid.

    Parameters
    ----------
    g : pp.Grid
        Coarse grid
    g_ref : pp.Grid
        Refined grid
    point_in_poly_tol : float, Optional
        Tolerance for pp.geometry_property_checks.point_in_polyhedron()

    Returns
    -------
    coarse_fine : sps.csc_matrix
        Column major sparse matrix mapping from coarse to fine cells.


    This method creates a mapping from fine to coarse cells by creating
    a matrix 'M' where the rows represent the fine cells while the
    columns represent the coarse cells. In practice this means that
    for an array 'p', of known values on a coarse grid, by applying
    the mapping
        q = M * p
    each value in a coarse cell will now be transferred to all the
    fine cells contained within the coarse cell.

    The procedure for creating this mapping relies on two main assumptions.
        1. Each fine cell is fully contained inside exactly one coarse cell.
        2. Each cell can be characterised as a simplex.
            - i.e. Every node except one defines every face of the object.

    The first assumption implies that the problem of assessing if a fine
    cell is contained within a coarse cell is reduced to assessing if
    the center of a fine cell is contained within the coarse cell.

    The second assumption implies that a cell in any dimension (1D, 2D, 3D)
    will be a convex object. This way, we can use existing algorithms in
    PorePy to find if a point is inside a polygon (2D) or polyhedron (3D).
    (The 1D case is trivial)

    The general algorithm is as follows (refer to start of for-loop in
    the code):
    1. Make a list of (pointers to) untested cell centers called
        'test_cells_ptr'.
    2. Iterate through all coarse cells. Now, consider one of these:
    3. For all untested cell centers (defined by 'test_cells_ptr'),
        check if they are inside the coarse cell.
    4. Those that pass (is inside the coarse cell) add to the mapping,
        then remove those point from the list of untested cell centers.
    5. Assemble the mapping.

    """

    assert g.num_cells < g_ref.num_cells, "Wrong order of input grids"
    assert g.dim == g_ref.dim, "Grids must be of same dimension"

    # 1. Step: Create a list of tuples pointing to the (start, end)
    # index of the nodes of each cell on the coarse grid.
    cell_nodes = g.cell_nodes()
    # start/end row pointers for each column
    nodes_of_cell_ptr = zip(cell_nodes.indptr[:-1], cell_nodes.indptr[1:])

    # 2. Step: Initialize a sps.csc_matrix mapping fine cells to
    # coarse cells.
    indptr = np.array([0])
    indices = np.empty(0)

    cells_ref = g_ref.cell_centers.copy()  # Cell centers in fine grid
    test_cells_ptr = np.arange(g_ref.num_cells)  # Pointer to cell centers
    nodes = g.nodes.copy()

    # 3. Step: If the grids are in 1D or 2D, we can simplify the
    # calculation by rotating the coordinate system to local
    # coordinates. For example, a 2D grid embedded in 3D
    # would be "rotated" so that each coordinate
    #           is of the form (x, y, 0).
    if g.dim == 1:
        # Rotate coarse nodes and fine cell centers to align with the x-axis
        tangent = pp.map_geometry.compute_tangent(nodes)
        reference = [1, 0, 0]
        R = pp.map_geometry.project_line_matrix(nodes, tangent, reference=reference,)
        nodes = R.dot(nodes)[0, :]
        cells_ref = R.dot(cells_ref)[0, :]

    elif g.dim == 2:  # Pre-processing for efficiency
        # Rotate coarse nodes and fine cell centers to the xy-plane.
        R = pp.map_geometry.project_plane_matrix(nodes, check_planar=False)
        nodes = np.dot(R, nodes)[:2, :]
        cells_ref = np.dot(R, cells_ref)[:2, :]

    # 4. Step: Loop through every coarse cell
    for st, nd in nodes_of_cell_ptr:

        nodes_idx = cell_nodes.indices[st:nd]
        num_nodes = nodes_idx.size

        # 5. Step: for the appropriate grid dimension, test all cell centers not already
        # found to be inside some other coarse cell.
        # 'in_poly' is a boolean array that is True for the points inside and False for
        # the points not inside.
        if g.dim == 1:
            # In 1D, we use a numpy method to check which coarse cell the fine points
            # are inside.
            assert num_nodes == 2, "We assume a 'cell' in 1D is defined by two points."
            line = np.sort(nodes[nodes_idx])
            test_points = cells_ref[test_cells_ptr]
            in_poly = np.searchsorted(line, test_points, side="left") == 1

        elif g.dim == 2:
            assert num_nodes == 3, "We assume simplexes in 2D (i.e. 3 nodes)"
            polygon = nodes[:, nodes_idx]
            test_points = cells_ref[:, test_cells_ptr]
            in_poly = pp.geometry_property_checks.point_in_polygon(
                poly=polygon, p=test_points, tol=point_in_poly_tol
            )

        elif g.dim == 3:
            # Make polyhedron from node coordinates.
            # Polyhedron defined as a list of nodes defining its (convex) faces.
            # Assumes simplexes: Every node except one defines every face.
            assert num_nodes == 4, "We assume simplexes in 3D (i.e. 4 nodes)"
            node_coords = nodes[:, nodes_idx]

            ids = np.arange(num_nodes)
            polyhedron = [node_coords[:, ids != i] for i in np.arange(num_nodes)]
            # Test only points not inside another polyhedron.
            test_points = cells_ref[:, test_cells_ptr]
            in_poly = pp.geometry_property_checks.point_in_polyhedron(
                polyhedron=polyhedron, test_points=test_points, tol=point_in_poly_tol
            )

        else:
            logger.warning(f"A grid of dimension {g.dim} encountered. Skip!")
            continue

        # 6. Step: Update pointer to which cell centers to use as test points
        in_poly_ids = test_cells_ptr[in_poly]  # id of cells inside this polyhedron
        # Keep only cells not inside this polyhedron
        test_cells_ptr = test_cells_ptr[~in_poly]

        # Update mapping
        indices = np.append(indices, in_poly_ids)
        indptr = np.append(indptr, indptr[-1] + in_poly_ids.size)

    # 7. Step: assemble the sparse matrix with the mapping.
    data = np.ones(indices.size)
    coarse_fine = sps.csc_matrix((data, indices, indptr))

    assert (
        indices.size == g_ref.num_cells
    ), "Every fine cell should be inside exactly one coarse cell"
    return coarse_fine
